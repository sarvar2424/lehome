<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEORA Voice Wave — Standing Wave + Flow + Pulse</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      height: 100%;
      margin: 0;
      background:
        radial-gradient(1200px 800px at 30% 25%, #111421 0%, #0a0f1a 55%, #090c16 75%, #05060b 100%),
        radial-gradient(900px 700px at 85% 70%, rgba(120, 40, 90, 0.5), transparent 60%),
        #05070b;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Text", Segoe UI, Roboto, Helvetica, Arial;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wrap {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      position: relative;
      padding-bottom: 80px;
    }

    .orb-shell {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .orb-shell::before {
      content: "";
      position: absolute;
      width: min(90vmin, 760px);
      height: min(90vmin, 760px);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 20% 25%, rgba(120, 220, 255, 0.35), transparent 55%),
        radial-gradient(circle at 80% 35%, rgba(180, 120, 255, 0.3), transparent 58%),
        radial-gradient(circle at 30% 80%, rgba(255, 120, 190, 0.25), transparent 60%);
      filter: blur(36px);
      opacity: 0.9;
      z-index: -2;
    }

    .orb-shell::after {
      content: "";
      position: absolute;
      width: min(72vmin, 600px);
      height: min(72vmin, 600px);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 50% 10%, rgba(255, 255, 255, 0.12), transparent 60%),
        radial-gradient(circle at 50% 90%, rgba(60, 120, 255, 0.1), transparent 70%);
      filter: blur(18px);
      opacity: 0.75;
      z-index: -1;
    }

    canvas {
      width: min(70vmin, 540px);
      height: min(70vmin, 540px);
      display: block;
    }

    .labels {
      margin-top: 26px;
      text-align: center;
      pointer-events: none;
    }

    .labels .title {
      font-size: 14px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #f9fafb;
      margin-bottom: 6px;
    }

    .labels .subtitle {
      font-size: 13px;
      color: rgba(209, 213, 219, 0.65);
    }

    .panel {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(10, 12, 18, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.18);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 10px 12px;
      align-items: center;
      box-shadow:
        0 16px 32px rgba(0,0,0,.55),
        0 0 40px rgba(79, 70, 229, 0.25);
    }

    .btn {
      appearance: none;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: radial-gradient(circle at 0 0, rgba(148, 163, 253, 0.12), rgba(30, 41, 59, 0.8));
      color: #e2e8f0;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      letter-spacing: .02em;
      font-size: 13px;
      transition: background 0.18s ease, border-color 0.18s ease, transform 0.12s ease;
    }
    .btn:hover {
      background: radial-gradient(circle at 0 0, rgba(191, 219, 254, 0.18), rgba(30, 64, 175, 0.85));
      transform: translateY(-1px);
    }
    .btn[aria-pressed="true"] {
      background: linear-gradient(180deg, rgba(59,130,246,.45), rgba(59,130,246,.18));
      border-color: rgba(147,197,253,.75);
    }

    .info {
      font-size: 12px;
      color: #94a3b8;
      margin-left: 4px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="orb-shell">
      <canvas id="sphere"></canvas>
      <div class="labels">
        <div class="title">LISTENING</div>
        <div class="subtitle">Speak naturally</div>
      </div>
    </div>

    <div class="panel" role="toolbar" aria-label="controls">
      <button id="idle" class="btn" aria-pressed="true">Idle</button>
      <button id="analysis" class="btn" aria-pressed="false">Analysis</button>
      <button id="active" class="btn" aria-pressed="false">Active</button>
      <button id="mic" class="btn" aria-pressed="false">Mic</button>
      <span class="info" id="msg"></span>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      const canvas = document.getElementById('sphere');
      const ctx = canvas.getContext('2d', { alpha: true });

      const DPR_MAX = 2;
      let dpr = Math.min(DPR_MAX, window.devicePixelRatio || 1);

      const state = {
        mode: 'idle',
        amp: 0.05,
        targetAmp: 0.05,
        smoothedRms: 0,
        time: 0,           // Время для движения волн
        timeSpeed: 0,      // Скорость движения
        targetTimeSpeed: 0,
      };

      let audioCtx = null;
      let analyser = null;
      let micStream = null;
      let timeData = null;

      function setCanvasSize() {
        const wCss = canvas.clientWidth || 540;
        const hCss = canvas.clientHeight || 540;
        dpr = Math.min(DPR_MAX, window.devicePixelRatio || 1);
        canvas.width = Math.floor(wCss * dpr);
        canvas.height = Math.floor(hCss * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      const resizeObserver = new ResizeObserver(setCanvasSize);
      resizeObserver.observe(canvas);
      setCanvasSize();

      const TAU = Math.PI * 2;
      const PI = Math.PI;
      const lerp = (a, b, t) => a + (b - a) * t;
      const clamp = (x, min, max) => Math.min(max, Math.max(min, x));

      const cyanColor = { r: 77, g: 208, b: 255 };
      const purpleColor = { r: 164, g: 91, b: 255 };
      const pinkColor = { r: 255, g: 101, b: 230 };

      function lerpColor(color1, color2, t) {
        const r = Math.round(color1.r + (color2.r - color1.r) * t);
        const g = Math.round(color1.g + (color2.g - color1.g) * t);
        const b = Math.round(color1.b + (color2.b - color1.b) * t);
        return { r, g, b };
      }

      function fillSphereBase(cx, cy, r) {
        const gradient = ctx.createRadialGradient(cx, cy * 0.7, r * 0.06, cx, cy, r);
        gradient.addColorStop(0.0, '#0f1520');
        gradient.addColorStop(0.35, '#0b1220');
        gradient.addColorStop(0.7, '#070e18');
        gradient.addColorStop(1.0, '#040710');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();
      }

      function addGleams(cx, cy, r) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';

        const colorGleam = ctx.createRadialGradient(
          cx - r * 0.5, cy + r * 0.5, r * 0.05,
          cx - r * 0.3, cy + r * 0.4, r * 0.6
        );
        colorGleam.addColorStop(0.0, 'rgba(255, 140, 90, 0.25)');
        colorGleam.addColorStop(0.5, 'rgba(200, 100, 150, 0.15)');
        colorGleam.addColorStop(1.0, 'rgba(0,0,0,0)');

        ctx.fillStyle = colorGleam;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();

        const rightGleam = ctx.createRadialGradient(
          cx + r * 0.5, cy + r * 0.3, r * 0.05,
          cx + r * 0.4, cy + r * 0.2, r * 0.5
        );
        rightGleam.addColorStop(0.0, 'rgba(100, 120, 255, 0.2)');
        rightGleam.addColorStop(0.5, 'rgba(150, 100, 200, 0.1)');
        rightGleam.addColorStop(1.0, 'rgba(0,0,0,0)');

        ctx.fillStyle = rightGleam;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();

        ctx.beginPath();
        ctx.ellipse(cx - r * 0.05, cy - r * 0.42, r * 0.9, r * 0.5, -0.12, 0, TAU);

        const whiteGleam = ctx.createRadialGradient(
          cx - r * 0.25, cy - r * 0.52, r * 0.08,
          cx - r * 0.05, cy - r * 0.4, r * 0.7
        );
        whiteGleam.addColorStop(0.0, 'rgba(255,255,255,0.2)');
        whiteGleam.addColorStop(0.18, 'rgba(255,255,255,0.08)');
        whiteGleam.addColorStop(0.4, 'rgba(210,230,255,0.03)');
        whiteGleam.addColorStop(1.0, 'rgba(0,0,0,0)');

        ctx.fillStyle = whiteGleam;
        ctx.fill();

        ctx.restore();
      }

      // ---------------------------------------------------------------------
      // СТОЯЧАЯ ВОЛНА + ДВИЖЕНИЕ + ПУЛЬС
      // ---------------------------------------------------------------------
      function drawFlowingStandingWaves(cx, cy, r, time, intensity) {
        const waveWidth = r * 2.1;
        const startX = cx - r * 1.05;
        const numPoints = 200;

        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r - 1, 0, TAU);
        ctx.clip();

        const numLinesPerRibbon = 70;

        // Огибающая стоячей волны - широко по краям, узко в узлах
        function standingWaveEnvelope(t) {
          const nodes = Math.abs(Math.cos(t * PI * 3));
          return 0.15 + nodes * 0.85;
        }

        function generateRibbon(verticalDirection, baseVerticalOffset, timeDirection) {
          const lines = [];
          
          for (let lineIdx = 0; lineIdx < numLinesPerRibbon; lineIdx++) {
            const lineT = lineIdx / (numLinesPerRibbon - 1);
            
            const phaseOffset = lineT * PI * 2.2 + Math.sin(lineT * PI * 2.5) * 0.6;
            const amplitudeVariation = 0.5 + Math.sin(lineT * PI * 2 + 0.3) * 0.5;
            const verticalSpread = (lineT - 0.5) * 50;
            const speedVariation = 0.8 + lineT * 0.4;
            
            const points = [];
            
            for (let i = 0; i <= numPoints; i++) {
              const t = i / numPoints;
              const x = startX + t * waveWidth;

              // Огибающая стоячей волны
              const envelope = standingWaveEnvelope(t);
              
              // Форма волны С ДВИЖЕНИЕМ - time добавляет бегущую составляющую
              const wave1 = Math.sin(t * PI * 3 + time * speedVariation * timeDirection + phaseOffset) * 70 * amplitudeVariation;
              const wave2 = Math.sin(t * PI * 2 + time * 0.7 * timeDirection + phaseOffset * 0.6) * 35 * amplitudeVariation;
              const wave3 = Math.sin(t * PI * 5 + time * 1.2 * timeDirection + lineT * PI * 1.5) * 18;

              const baseWaveY = (wave1 + wave2 + wave3) * envelope;
              const waveY = baseWaveY * intensity * verticalDirection;
              const verticalOffset = (baseVerticalOffset + verticalSpread) * intensity * envelope;
              
              const y = cy + waveY + verticalOffset;

              points.push({ x, y, t, envelope });
            }
            
            lines.push({
              points,
              lineT,
              baseAlpha: 0.1 + Math.sin(lineT * PI) * 0.4
            });
          }
          return lines;
        }

        // Cyan движется в одну сторону, Pink в другую - создаёт эффект переплетения
        const cyanRibbon = generateRibbon(-1, -25, 1);
        const pinkRibbon = generateRibbon(1, 25, -1);

        function drawRibbonSegment(ribbon, baseColor, toColor, start, end) {
          for (const line of ribbon) {
            ctx.lineWidth = 0.55;
            
            for (let i = start; i < end && i < line.points.length - 1; i++) {
              const pt1 = line.points[i];
              const pt2 = line.points[i + 1];
              
              const centerT = Math.abs(pt1.t - 0.5) * 2;
              const color = lerpColor(toColor, baseColor, centerT);
              
              const alpha = line.baseAlpha * (0.4 + intensity * 0.6) * (0.5 + pt1.envelope * 0.5);
              ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
              ctx.beginPath();
              ctx.moveTo(pt1.x, pt1.y);
              ctx.lineTo(pt2.x, pt2.y);
              ctx.stroke();
            }
          }
        }

        const segments = 6;
        const pointsPerSegment = Math.floor(numPoints / segments);

        for (let seg = 0; seg < segments; seg++) {
          const startIdx = seg * pointsPerSegment;
          const endIdx = Math.min((seg + 1) * pointsPerSegment, numPoints);

          if (seg % 2 === 0) {
            drawRibbonSegment(pinkRibbon, pinkColor, purpleColor, startIdx, endIdx);
            drawRibbonSegment(cyanRibbon, cyanColor, purpleColor, startIdx, endIdx);
          } else {
            drawRibbonSegment(cyanRibbon, cyanColor, purpleColor, startIdx, endIdx);
            drawRibbonSegment(pinkRibbon, pinkColor, purpleColor, startIdx, endIdx);
          }
        }

        // ====== ПУНКТИРНЫЕ ЦЕНТРАЛЬНЫЕ ЛИНИИ ======
        ctx.setLineDash([6, 10]);
        ctx.lineWidth = 1.0;
        
        const dashedOpacity = 0.45 + intensity * 0.35;

        // Cyan пунктир (движется в одну сторону)
        ctx.beginPath();
        for (let i = 0; i <= numPoints; i++) {
          const t = i / numPoints;
          const x = startX + t * waveWidth;
          
          const envelope = standingWaveEnvelope(t);
          const wave1 = Math.sin(t * PI * 3 + time * 1.0) * 55;
          const wave2 = Math.sin(t * PI * 2 + time * 0.6) * 28;
          const baseY = (wave1 + wave2) * envelope;
          
          const y = cy + baseY * intensity * (-1) - 25 * intensity * envelope;

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        
        const cyanGradient = ctx.createLinearGradient(startX, cy, startX + waveWidth, cy);
        cyanGradient.addColorStop(0, `rgba(77, 208, 255, ${dashedOpacity})`);
        cyanGradient.addColorStop(0.5, `rgba(164, 91, 255, ${dashedOpacity * 0.85})`);
        cyanGradient.addColorStop(1, `rgba(77, 208, 255, ${dashedOpacity})`);
        ctx.strokeStyle = cyanGradient;
        ctx.stroke();

        // Pink пунктир (движется в другую сторону)
        ctx.beginPath();
        for (let i = 0; i <= numPoints; i++) {
          const t = i / numPoints;
          const x = startX + t * waveWidth;
          
          const envelope = standingWaveEnvelope(t);
          const wave1 = Math.sin(t * PI * 3 - time * 1.0) * 55;
          const wave2 = Math.sin(t * PI * 2 - time * 0.6) * 28;
          const baseY = (wave1 + wave2) * envelope;
          
          const y = cy + baseY * intensity * (1) + 25 * intensity * envelope;

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        
        const pinkGradient = ctx.createLinearGradient(startX, cy, startX + waveWidth, cy);
        pinkGradient.addColorStop(0, `rgba(255, 101, 230, ${dashedOpacity})`);
        pinkGradient.addColorStop(0.5, `rgba(164, 91, 255, ${dashedOpacity * 0.85})`);
        pinkGradient.addColorStop(1, `rgba(255, 101, 230, ${dashedOpacity})`);
        ctx.strokeStyle = pinkGradient;
        ctx.stroke();
        
        ctx.setLineDash([]);
        ctx.restore();
      }

      function animate() {
        
        if (state.mode === 'mic' && analyser && timeData) {
          analyser.getByteTimeDomainData(timeData);
          let sumOfSquares = 0;
          const dataLength = timeData.length;

          for (let i = 0; i < dataLength; i++) {
            const normalized = (timeData[i] - 128) / 128;
            sumOfSquares += normalized * normalized;
          }

          const rms = Math.sqrt(sumOfSquares / dataLength);
          state.smoothedRms = lerp(state.smoothedRms, rms, 0.35);
          
          const silenceThreshold = 0.01;
          
          if (state.smoothedRms > silenceThreshold) {
            // Звук есть - амплитуда и скорость увеличиваются
            const soundLevel = clamp((state.smoothedRms - silenceThreshold) * 10, 0, 1);
            state.targetAmp = 0.3 + soundLevel * 0.7;
            state.targetTimeSpeed = 0.8 + soundLevel * 1.2; // Быстрее при громком звуке
          } else {
            // Тишина - амплитуда падает, движение замедляется
            state.targetAmp = 0.03;
            state.targetTimeSpeed = 0.1; // Почти остановка
          }
          
          // Плавное изменение амплитуды
          const ampSpeed = state.targetAmp > state.amp ? 0.25 : 0.08;
          state.amp = lerp(state.amp, state.targetAmp, ampSpeed);
          
          // Плавное изменение скорости
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.15);
          
        } else if (state.mode === 'idle') {
          state.targetAmp = 0.03;
          state.targetTimeSpeed = 0.15;
          state.amp = lerp(state.amp, state.targetAmp, 0.05);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.05);
          
        } else if (state.mode === 'analysis') {
          const breathe = (Math.sin(performance.now() / 1500) + 1) / 2;
          state.targetAmp = 0.15 + breathe * 0.25;
          state.targetTimeSpeed = 0.4 + breathe * 0.3;
          state.amp = lerp(state.amp, state.targetAmp, 0.1);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.1);
          
        } else if (state.mode === 'active') {
          const breathe = (Math.sin(performance.now() / 800) + 1) / 2;
          state.targetAmp = 0.85 + breathe * 0.15;
          state.targetTimeSpeed = 1.2 + breathe * 0.4;
          state.amp = lerp(state.amp, state.targetAmp, 0.15);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.15);
        }

        // Обновляем время для движения волн
        state.time += state.timeSpeed / 60;

        const canvasWidth = canvas.clientWidth || 540;
        const canvasHeight = canvas.clientHeight || 540;
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;
        const radius = Math.min(canvasWidth, canvasHeight) * 0.46;

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        fillSphereBase(centerX, centerY, radius);
        drawFlowingStandingWaves(centerX, centerY, radius, state.time, state.amp);
        addGleams(centerX, centerY, radius);

        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);

      // UI
      const idleBtn = document.getElementById('idle');
      const analysisBtn = document.getElementById('analysis');
      const activeBtn = document.getElementById('active');
      const micBtn = document.getElementById('mic');
      const msg = document.getElementById('msg');

      function setPressed(btn, pressed) {
        btn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
      }

      async function startMic() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          micStream = stream;
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          audioCtx = new AudioContext();
          const source = audioCtx.createMediaStreamSource(stream);
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 1024;
          analyser.smoothingTimeConstant = 0.8;
          source.connect(analyser);
          timeData = new Uint8Array(analyser.frequencyBinCount);
          
          msg.textContent = 'Mic on — speak!';
          state.mode = 'mic';
          setPressed(idleBtn, false);
          setPressed(analysisBtn, false);
          setPressed(activeBtn, false);
          setPressed(micBtn, true);
        } catch (error) {
          msg.textContent = 'No mic access';
          state.mode = 'active';
          setPressed(idleBtn, false);
          setPressed(analysisBtn, false);
          setPressed(activeBtn, true);
          setPressed(micBtn, false);
        }
      }

      function stopMic() {
        if (micStream) {
          micStream.getTracks().forEach(track => track.stop());
          micStream = null;
        }
        if (audioCtx) {
          audioCtx.close();
          audioCtx = null;
        }
        analyser = null;
        timeData = null;
      }

      idleBtn.addEventListener('click', () => {
        stopMic();
        state.mode = 'idle';
        setPressed(idleBtn, true);
        setPressed(analysisBtn, false);
        setPressed(activeBtn, false);
        setPressed(micBtn, false);
        msg.textContent = '';
      });

      analysisBtn.addEventListener('click', () => {
        stopMic();
        state.mode = 'analysis';
        setPressed(idleBtn, false);
        setPressed(analysisBtn, true);
        setPressed(activeBtn, false);
        setPressed(micBtn, false);
        msg.textContent = '';
      });

      activeBtn.addEventListener('click', () => {
        stopMic();
        state.mode = 'active';
        setPressed(idleBtn, false);
        setPressed(analysisBtn, false);
        setPressed(activeBtn, true);
        setPressed(micBtn, false);
        msg.textContent = '';
      });

      micBtn.addEventListener('click', () => {
        if (state.mode === 'mic') {
          stopMic();
          state.mode = 'idle';
          setPressed(idleBtn, true);
          setPressed(analysisBtn, false);
          setPressed(activeBtn, false);
          setPressed(micBtn, false);
          msg.textContent = '';
        } else {
          startMic();
        }
      });

      window.addEventListener('pagehide', stopMic);
    })();
  </script>
</body>
</html>
