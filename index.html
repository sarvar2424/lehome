<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEORA Voice Wave — Ultra Optimized</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      height: 100%;
      margin: 0;
      background:
        radial-gradient(1200px 800px at 30% 25%, #111421 0%, #0a0f1a 55%, #090c16 75%, #05060b 100%),
        radial-gradient(900px 700px at 85% 70%, rgba(120, 40, 90, 0.5), transparent 60%),
        #05070b;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Text", Segoe UI, Roboto, Helvetica, Arial;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wrap {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      position: relative;
      padding-bottom: 80px;
    }

    .orb-shell {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .orb-shell::before {
      content: "";
      position: absolute;
      width: min(90vmin, 760px);
      height: min(90vmin, 760px);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 20% 25%, rgba(120, 220, 255, 0.35), transparent 55%),
        radial-gradient(circle at 80% 35%, rgba(180, 120, 255, 0.3), transparent 58%),
        radial-gradient(circle at 30% 80%, rgba(255, 120, 190, 0.25), transparent 60%);
      filter: blur(36px);
      opacity: 0.9;
      z-index: -2;
    }

    .orb-shell::after {
      content: "";
      position: absolute;
      width: min(72vmin, 600px);
      height: min(72vmin, 600px);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 50% 10%, rgba(255, 255, 255, 0.12), transparent 60%),
        radial-gradient(circle at 50% 90%, rgba(60, 120, 255, 0.1), transparent 70%);
      filter: blur(18px);
      opacity: 0.75;
      z-index: -1;
    }

    canvas {
      width: min(70vmin, 540px);
      height: min(70vmin, 540px);
      display: block;
    }

    .labels {
      margin-top: 26px;
      text-align: center;
      pointer-events: none;
    }

    .labels .title {
      font-size: 14px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #f9fafb;
      margin-bottom: 6px;
    }

    .labels .subtitle {
      font-size: 13px;
      color: rgba(209, 213, 219, 0.65);
    }

    .panel {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(10, 12, 18, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.18);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 10px 12px;
      align-items: center;
      box-shadow:
        0 16px 32px rgba(0,0,0,.55),
        0 0 40px rgba(79, 70, 229, 0.25);
    }

    .btn {
      appearance: none;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: radial-gradient(circle at 0 0, rgba(148, 163, 253, 0.12), rgba(30, 41, 59, 0.8));
      color: #e2e8f0;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      letter-spacing: .02em;
      font-size: 13px;
      transition: background 0.18s ease, border-color 0.18s ease, transform 0.12s ease;
    }
    .btn:hover {
      background: radial-gradient(circle at 0 0, rgba(191, 219, 254, 0.18), rgba(30, 64, 175, 0.85));
      transform: translateY(-1px);
    }
    .btn[aria-pressed="true"] {
      background: linear-gradient(180deg, rgba(59,130,246,.45), rgba(59,130,246,.18));
      border-color: rgba(147,197,253,.75);
    }

    .info {
      font-size: 12px;
      color: #94a3b8;
      margin-left: 4px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="orb-shell">
      <canvas id="sphere"></canvas>
      <div class="labels">
        <div class="title" id="title">LISTENING</div>
        <div class="subtitle" id="subtitle">Speak naturally</div>
      </div>
    </div>

    <div class="panel" role="toolbar" aria-label="controls">
      <button id="idle" class="btn" aria-pressed="true">Idle</button>
      <button id="analysis" class="btn" aria-pressed="false">Analysis</button>
      <button id="active" class="btn" aria-pressed="false">Active</button>
      <button id="mic" class="btn" aria-pressed="false">Mic</button>
      <span class="info" id="msg"></span>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      const canvas = document.getElementById('sphere');
      const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      const titleEl = document.getElementById('title');
      const subtitleEl = document.getElementById('subtitle');

      const DPR_MAX = 1.5;
      let dpr = Math.min(DPR_MAX, window.devicePixelRatio || 1);

      const state = {
        mode: 'idle',
        amp: 0.135,
        targetAmp: 0.135,
        smoothedRms: 0,
        time: 0,
        timeSpeed: 0,
        targetTimeSpeed: 0,
        analysisStartTime: 0,
        analysisPhase: 'analyzing',
        morphProgress: 0,
        lastLabelUpdate: 0,
        currentTitle: '',
        currentSubtitle: '',
      };

      const ANALYSIS_DURATION = 3000;
      const MORPH_DURATION = 1200;
      const LABEL_UPDATE_INTERVAL = 200; // Обновляем лейблы только раз в 200мс
      
      const NUM_LINES = 16;
      const NUM_POINTS = 60;

      let audioCtx = null;
      let analyser = null;
      let micStream = null;
      let timeData = null;

      const TAU = Math.PI * 2;
      const PI = Math.PI;

      // Предрассчитанные данные
      const lineData = [];
      const pointData = [];
      
      // Кэшированные градиенты
      const gradientCache = {
        waveTop: null,
        waveBottom: null,
        checkTop: null,
        checkBottom: null,
        needsUpdate: true,
      };
      
      function precalcData() {
        lineData.length = 0;
        for (let i = 0; i < NUM_LINES; i++) {
          const t = i / (NUM_LINES - 1);
          lineData.push({
            t,
            phase: t * PI * 2.2 + Math.sin(t * PI * 2.5) * 0.6,
            ampVar: 0.5 + Math.sin(t * PI * 2 + 0.3) * 0.5,
            vSpread: (t - 0.5) * 50,
            speed: 0.8 + t * 0.4,
            alpha: 0.15 + Math.sin(t * PI) * 0.45,
          });
        }
        
        pointData.length = 0;
        for (let i = 0; i <= NUM_POINTS; i++) {
          const t = i / NUM_POINTS;
          const nodes = Math.abs(Math.cos(t * PI * 3));
          pointData.push({
            t,
            env: 0.15 + nodes * 0.85,
          });
        }
      }
      precalcData();

      // Цвета
      const cyanColor = [77, 208, 255];
      const purpleColor = [164, 91, 255];
      const pinkColor = [255, 101, 230];
      const blueColor = [59, 130, 246];

      function setCanvasSize() {
        const wCss = canvas.clientWidth || 540;
        const hCss = canvas.clientHeight || 540;
        dpr = Math.min(DPR_MAX, window.devicePixelRatio || 1);
        canvas.width = Math.floor(wCss * dpr);
        canvas.height = Math.floor(hCss * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        gradientCache.needsUpdate = true;
      }

      const resizeObserver = new ResizeObserver(setCanvasSize);
      resizeObserver.observe(canvas);
      setCanvasSize();

      const lerp = (a, b, t) => a + (b - a) * t;
      const clamp = (x, min, max) => Math.min(max, Math.max(min, x));
      const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      function createGradients(cx, cy, r) {
        const waveWidth = r * 2.1;
        const startX = cx - r * 1.05;

        const gradTop = ctx.createLinearGradient(startX, cy, startX + waveWidth, cy);
        gradTop.addColorStop(0, `rgba(${cyanColor.join(',')}, 1)`);
        gradTop.addColorStop(0.35, `rgba(${purpleColor.join(',')}, 1)`);
        gradTop.addColorStop(0.5, `rgba(${purpleColor.join(',')}, 1)`);
        gradTop.addColorStop(0.65, `rgba(${purpleColor.join(',')}, 1)`);
        gradTop.addColorStop(1, `rgba(${cyanColor.join(',')}, 1)`);
        
        const gradBottom = ctx.createLinearGradient(startX, cy, startX + waveWidth, cy);
        gradBottom.addColorStop(0, `rgba(${pinkColor.join(',')}, 1)`);
        gradBottom.addColorStop(0.35, `rgba(${purpleColor.join(',')}, 1)`);
        gradBottom.addColorStop(0.5, `rgba(${purpleColor.join(',')}, 1)`);
        gradBottom.addColorStop(0.65, `rgba(${purpleColor.join(',')}, 1)`);
        gradBottom.addColorStop(1, `rgba(${pinkColor.join(',')}, 1)`);

        const gradCheckTop = ctx.createLinearGradient(
          cx - r * 0.5, cy + r * 0.4,
          cx + r * 0.5, cy - r * 0.4
        );
        gradCheckTop.addColorStop(0, `rgba(${pinkColor.join(',')}, 1)`);
        gradCheckTop.addColorStop(0.3, `rgba(${purpleColor.join(',')}, 1)`);
        gradCheckTop.addColorStop(0.5, `rgba(${blueColor.join(',')}, 1)`);
        gradCheckTop.addColorStop(0.7, `rgba(${cyanColor.join(',')}, 1)`);
        gradCheckTop.addColorStop(1, `rgba(${cyanColor.join(',')}, 1)`);
        
        const gradCheckBottom = ctx.createLinearGradient(
          cx - r * 0.5, cy + r * 0.4,
          cx + r * 0.5, cy - r * 0.4
        );
        gradCheckBottom.addColorStop(0, `rgba(${pinkColor.join(',')}, 1)`);
        gradCheckBottom.addColorStop(0.3, `rgba(${purpleColor.join(',')}, 1)`);
        gradCheckBottom.addColorStop(0.5, `rgba(${blueColor.join(',')}, 1)`);
        gradCheckBottom.addColorStop(0.7, `rgba(${cyanColor.join(',')}, 1)`);
        gradCheckBottom.addColorStop(1, `rgba(${cyanColor.join(',')}, 1)`);

        return {
          waveTop: gradTop,
          waveBottom: gradBottom,
          checkTop: gradCheckTop,
          checkBottom: gradCheckBottom,
        };
      }

      function fillSphereBase(cx, cy, r) {
        const gradient = ctx.createRadialGradient(cx, cy, r * 0.1, cx, cy, r);
        gradient.addColorStop(0.0, '#12161f');
        gradient.addColorStop(0.6, '#0a0d14');
        gradient.addColorStop(1.0, '#050709');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();

        ctx.strokeStyle = 'rgba(120, 140, 180, 0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, r - 1, 0, TAU);
        ctx.stroke();
      }

      function addGleams(cx, cy, r) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';

        const highlight = ctx.createRadialGradient(
          cx - r * 0.3, cy - r * 0.4, r * 0.02,
          cx - r * 0.1, cy - r * 0.2, r * 0.6
        );
        highlight.addColorStop(0.0, 'rgba(255, 255, 255, 0.18)');
        highlight.addColorStop(0.3, 'rgba(255, 255, 255, 0.05)');
        highlight.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = highlight;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();

        ctx.restore();
      }

      // Кэш для точек галочки
      const checkPointCache = new Map();
      
      function getCheckPoint(t, cx, cy, r) {
        const key = `${t.toFixed(3)}_${cx}_${cy}_${r}`;
        if (checkPointCache.has(key)) return checkPointCache.get(key);
        
        const s = r * 0.75;
        const sx = cx - s * 0.55, sy = cy + s * 0.05;
        const mx = cx - s * 0.15, my = cy + s * 0.45;
        const ex = cx + s * 0.55, ey = cy - s * 0.4;
        
        let result;
        if (t < 0.4) {
          const lt = t / 0.4;
          result = [lerp(sx, mx, lt), lerp(sy, my, lt)];
        } else {
          const lt = (t - 0.4) / 0.6;
          result = [lerp(mx, ex, lt), lerp(my, ey, lt)];
        }
        
        checkPointCache.set(key, result);
        return result;
      }

      function drawWaves(cx, cy, r, time, intensity, morphProgress) {
        const waveWidth = r * 2.1;
        const startX = cx - r * 1.05;
        const easedMorph = easeInOutCubic(morphProgress);

        // Обновляем градиенты только при необходимости
        if (gradientCache.needsUpdate) {
          const grads = createGradients(cx, cy, r);
          gradientCache.waveTop = grads.waveTop;
          gradientCache.waveBottom = grads.waveBottom;
          gradientCache.checkTop = grads.checkTop;
          gradientCache.checkBottom = grads.checkBottom;
          gradientCache.needsUpdate = false;
        }

        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r - 1, 0, TAU);
        ctx.clip();

        const gradients = [
          [gradientCache.waveTop, gradientCache.checkTop],
          [gradientCache.waveBottom, gradientCache.checkBottom]
        ];

        // Оптимизация: используем Path2D для batch-обработки
        for (let ribbon = 0; ribbon < 2; ribbon++) {
          const vDir = ribbon === 0 ? -1 : 1;
          const baseOff = ribbon === 0 ? -25 : 25;
          const tDir = ribbon === 0 ? 1 : -1;
          
          const waveGrad = gradients[ribbon][0];
          const checkGrad = gradients[ribbon][1];

          for (let li = 0; li < NUM_LINES; li++) {
            const ld = lineData[li];
            const checkSpread = (ld.t - 0.5) * 12 * (1 - easedMorph * 0.7);

            const path = new Path2D();
            
            for (let pi = 0; pi <= NUM_POINTS; pi++) {
              const pd = pointData[pi];
              const t = pd.t;
              
              const w1 = Math.sin(t * PI * 3 + time * ld.speed * tDir + ld.phase) * 70 * ld.ampVar;
              const w2 = Math.sin(t * PI * 2 + time * 0.7 * tDir + ld.phase * 0.6) * 35 * ld.ampVar;
              const w3 = Math.sin(t * PI * 5 + time * 1.2 * tDir + ld.t * PI * 1.5) * 18;
              const waveY = (w1 + w2 + w3) * pd.env;
              
              const wx = startX + t * waveWidth;
              const wy = cy + waveY * intensity * vDir + (baseOff + ld.vSpread) * intensity * pd.env;
              
              const [chkX, chkY] = getCheckPoint(t, cx, cy, r);
              const fx = lerp(wx, chkX, easedMorph);
              const fy = lerp(wy, chkY + checkSpread * vDir, easedMorph);

              if (pi === 0) path.moveTo(fx, fy);
              else path.lineTo(fx, fy);
            }
            
            ctx.lineWidth = lerp(0.8, 9, easedMorph);
            ctx.globalAlpha = ld.alpha * (0.4 + intensity * 0.6) * lerp(1, 1.5, easedMorph);
            ctx.strokeStyle = easedMorph < 0.5 ? waveGrad : checkGrad;
            ctx.stroke(path);
          }
        }

        ctx.globalAlpha = 1;

        // Пунктир (только если нужен)
        if (morphProgress < 0.5) {
          const dashAlpha = (1 - morphProgress * 2) * (0.4 + intensity * 0.3);
          ctx.setLineDash([6, 10]);
          ctx.lineWidth = 1;
          ctx.globalAlpha = dashAlpha;

          for (let ribbon = 0; ribbon < 2; ribbon++) {
            const vDir = ribbon === 0 ? -1 : 1;
            const tDir = ribbon === 0 ? 1 : -1;
            const color = ribbon === 0 ? cyanColor : pinkColor;

            const path = new Path2D();
            ctx.strokeStyle = `rgb(${color.join(',')})`;

            for (let pi = 0; pi <= NUM_POINTS; pi++) {
              const pd = pointData[pi];
              const t = pd.t;
              const w1 = Math.sin(t * PI * 3 + time * tDir) * 55;
              const w2 = Math.sin(t * PI * 2 + time * 0.6 * tDir) * 28;
              const waveY = (w1 + w2) * pd.env;
              
              const wx = startX + t * waveWidth;
              const wy = cy + waveY * intensity * vDir + 25 * intensity * pd.env * vDir;
              
              const [chkX, chkY] = getCheckPoint(t, cx, cy, r);
              const fx = lerp(wx, chkX, easedMorph);
              const fy = lerp(wy, chkY + 5 * vDir, easedMorph);

              if (pi === 0) path.moveTo(fx, fy);
              else path.lineTo(fx, fy);
            }
            ctx.stroke(path);
          }
          ctx.setLineDash([]);
        }

        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Оптимизированное обновление лейблов - только когда реально изменился текст
      function updateLabels(force = false) {
        let newTitle = '';
        let newSubtitle = '';

        if (state.mode === 'analysis') {
          const elapsed = performance.now() - state.analysisStartTime;
          const remaining = Math.max(0, Math.ceil((ANALYSIS_DURATION - elapsed) / 1000));
          
          if (state.analysisPhase === 'analyzing') {
            newTitle = 'ANALYZING';
            newSubtitle = remaining > 0 ? `${remaining}s remaining...` : 'Finishing...';
          } else {
            newTitle = 'COMPLETE';
            newSubtitle = 'Analysis finished';
          }
        } else if (state.mode === 'mic') {
          newTitle = 'LISTENING';
          newSubtitle = 'Speak naturally';
        } else if (state.mode === 'idle') {
          newTitle = 'READY';
          newSubtitle = 'Select a mode';
        } else if (state.mode === 'active') {
          newTitle = 'ACTIVE';
          newSubtitle = 'Processing...';
        }

        // Обновляем DOM только если текст действительно изменился
        if (force || newTitle !== state.currentTitle) {
          titleEl.textContent = newTitle;
          state.currentTitle = newTitle;
        }
        if (force || newSubtitle !== state.currentSubtitle) {
          subtitleEl.textContent = newSubtitle;
          state.currentSubtitle = newSubtitle;
        }
      }

      let lastFrame = 0;
      
      function animate(now) {
        // Динамический FPS для плавности
        const targetFPS = state.mode === 'analysis' ? 45 : 60;
        const frameTime = 1000 / targetFPS;
        
        if (now - lastFrame < frameTime * 0.95) {
          requestAnimationFrame(animate);
          return;
        }
        lastFrame = now;
        
        if (state.mode === 'mic' && analyser && timeData) {
          analyser.getByteTimeDomainData(timeData);
          let sum = 0;
          for (let i = 0; i < timeData.length; i++) {
            const n = (timeData[i] - 128) / 128;
            sum += n * n;
          }
          const rms = Math.sqrt(sum / timeData.length);
          state.smoothedRms = lerp(state.smoothedRms, rms, 0.35);
          
          if (state.smoothedRms > 0.01) {
            const lvl = clamp((state.smoothedRms - 0.01) * 10, 0, 1);
            state.targetAmp = 0.3 + lvl * 0.7;
            state.targetTimeSpeed = 0.8 + lvl * 1.2;
          } else {
            state.targetAmp = 0.135;
            state.targetTimeSpeed = 0.45;
          }
          
          state.amp = lerp(state.amp, state.targetAmp, state.targetAmp > state.amp ? 0.25 : 0.08);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.15);
          state.morphProgress = lerp(state.morphProgress, 0, 0.1);
          
        } else if (state.mode === 'idle') {
          state.targetAmp = 0.135;
          state.targetTimeSpeed = 0.675;
          state.amp = lerp(state.amp, state.targetAmp, 0.05);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.05);
          state.morphProgress = lerp(state.morphProgress, 0, 0.1);
          
        } else if (state.mode === 'analysis') {
          const elapsed = now - state.analysisStartTime;
          
          if (elapsed < ANALYSIS_DURATION) {
            state.analysisPhase = 'analyzing';
            const breathe = (Math.sin(now / 600) + 1) / 2;
            state.targetAmp = 0.3 + breathe * 0.3;
            state.targetTimeSpeed = 0.6 + breathe * 0.5;
            state.morphProgress = lerp(state.morphProgress, 0, 0.1);
          } else if (elapsed < ANALYSIS_DURATION + MORPH_DURATION) {
            state.analysisPhase = 'morphing';
            state.morphProgress = clamp((elapsed - ANALYSIS_DURATION) / MORPH_DURATION, 0, 1);
            state.targetAmp = lerp(0.5, 0.6, state.morphProgress);
            state.targetTimeSpeed = lerp(0.6, 0.02, state.morphProgress);
          } else {
            state.analysisPhase = 'complete';
            state.morphProgress = 1;
            state.targetAmp = 0.6;
            state.targetTimeSpeed = 0.02;
          }
          
          state.amp = lerp(state.amp, state.targetAmp, 0.12);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.12);
          
          // Обновляем лейблы только периодически, не каждый кадр!
          if (now - state.lastLabelUpdate > LABEL_UPDATE_INTERVAL) {
            updateLabels();
            state.lastLabelUpdate = now;
          }
          
        } else if (state.mode === 'active') {
          const breathe = (Math.sin(now / 800) + 1) / 2;
          state.targetAmp = 0.85 + breathe * 0.15;
          state.targetTimeSpeed = 1.2 + breathe * 0.4;
          state.amp = lerp(state.amp, state.targetAmp, 0.15);
          state.timeSpeed = lerp(state.timeSpeed, state.targetTimeSpeed, 0.15);
          state.morphProgress = lerp(state.morphProgress, 0, 0.1);
        }

        state.time += state.timeSpeed / 60;

        const w = canvas.clientWidth || 540;
        const h = canvas.clientHeight || 540;
        const cx = w / 2;
        const cy = h / 2;
        const r = Math.min(w, h) * 0.46;

        ctx.clearRect(0, 0, w, h);
        fillSphereBase(cx, cy, r);
        drawWaves(cx, cy, r, state.time, state.amp, state.morphProgress);
        addGleams(cx, cy, r);

        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);

      // UI
      const idleBtn = document.getElementById('idle');
      const analysisBtn = document.getElementById('analysis');
      const activeBtn = document.getElementById('active');
      const micBtn = document.getElementById('mic');
      const msg = document.getElementById('msg');

      function setPressed(btn, pressed) {
        btn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
      }

      async function startMic() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          micStream = stream;
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(stream);
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 512;
          analyser.smoothingTimeConstant = 0.8;
          source.connect(analyser);
          timeData = new Uint8Array(analyser.frequencyBinCount);
          
          msg.textContent = 'Mic on';
          state.mode = 'mic';
          updateLabels(true);
          setPressed(idleBtn, false);
          setPressed(analysisBtn, false);
          setPressed(activeBtn, false);
          setPressed(micBtn, true);
        } catch (e) {
          msg.textContent = 'No mic';
          state.mode = 'active';
          updateLabels(true);
          setPressed(activeBtn, true);
        }
      }

      function stopMic() {
        if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
        if (audioCtx) { audioCtx.close(); audioCtx = null; }
        analyser = null; timeData = null;
      }

      idleBtn.onclick = () => {
        stopMic();
        state.mode = 'idle';
        state.analysisPhase = 'analyzing';
        updateLabels(true);
        setPressed(idleBtn, true);
        setPressed(analysisBtn, false);
        setPressed(activeBtn, false);
        setPressed(micBtn, false);
        msg.textContent = '';
      };

      analysisBtn.onclick = () => {
        stopMic();
        state.mode = 'analysis';
        state.analysisStartTime = performance.now();
        state.analysisPhase = 'analyzing';
        state.morphProgress = 0;
        state.lastLabelUpdate = 0;
        checkPointCache.clear(); // Очищаем кэш при новом запуске
        updateLabels(true);
        setPressed(idleBtn, false);
        setPressed(analysisBtn, true);
        setPressed(activeBtn, false);
        setPressed(micBtn, false);
        msg.textContent = '';
      };

      activeBtn.onclick = () => {
        stopMic();
        state.mode = 'active';
        state.analysisPhase = 'analyzing';
        updateLabels(true);
        setPressed(idleBtn, false);
        setPressed(analysisBtn, false);
        setPressed(activeBtn, true);
        setPressed(micBtn, false);
        msg.textContent = '';
      };

      micBtn.onclick = () => {
        if (state.mode === 'mic') {
          stopMic();
          state.mode = 'idle';
          updateLabels(true);
          setPressed(idleBtn, true);
          setPressed(micBtn, false);
          msg.textContent = '';
        } else {
          startMic();
        }
      };

      window.addEventListener('pagehide', stopMic);
      updateLabels(true);
    })();
  </script>
</body>
</html>
